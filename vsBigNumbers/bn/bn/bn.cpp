/*
Смоделировать операцию деления целого числа длиной до 30 десятичных цифр на
действительное число в форме (zn)m.n Е N, где суммарная длина мантиссы (m+n)
– до 30 значащих цифр, а величина порядка N – до 5 цифр.

Результат выдать в форме (zn)0.m1 Е N1.

Условные обозначения (zn) – знак числа N, N1 – величина порядка E – основание
числа. Запись числа (zn)0.m Е N соответствует следующей записи числа
N mzn 10 *. 0) ( . Например, число 2.5 можно записать в виде: +0.25 E+1.

Порядок выполнения работы:
1.  Определить структуру данных для хранения длинного числа.
2.  Предусмотреть ввод и вывод чисел обязательно в том формате, который указан
в задании.
3.  Разбивать число на составляющие при вводе нельзя (т.е. число должно
считываться сразу полностью).
4.  STL не пользоваться.
*/

#include "stdafx.h"
#include "BigInt.h"
#include "BigFloat.h"
#include "bn_functions.h"

int main()
{
/*
	BigFloat c("123.47");

	// число: 1234.47
	// на выходе должно быть: +1.2347 Е+2
	// а на самом деле: +123.47Е+2
	// Выводы:
	/// 1. знак экспоненты - верный
	/// 2. порядок - верный
	/// 3. плавающая точка должна сдигаться влево, но она почему-то вообще не сдвигается
	/// 4. "съедается" пробел после мантиссы

	BigFloat d("0.089");

	// число: 0.089
	// на выходе должно быть: +8.9 Е-2
	// а на самом деле: +0.008 E-2
	// Выводы:
	/// 1. знак экспоненты - верный
	/// 2. порядок - верный
	/// 3. плавающая точка должна сдигаться вправо на 2, но она почему-то сдвигается влево на 1
	/// 4. "съедается" последняя цифра мантиссы
	std::cout
		<< "\nc: "
		<< c
		<< "\nd: "
		<< d
		<< "\n\n"
		;
*/
    
	std::string str("123456789");
	std::cout << "str: " << str << "\n\n";

	BigInt x(str);
	std::cout << "x: " << x << "\n\n";

	erase_part_of(str, 1, 7); // 19
	std::cout << "str after erasing characters from pos 1 to pos 7: " << str << "\n\n";

	x.erase_elem(1, 7); // 19
	std::cout << "x after erasing characters from pos 1 to pos 7: " << x << "\n\n";

/*
	x.erase_elem(1);	// 1
	std::cout << "x after erasing 7: " << x << "\n";

	std::cout << "x.first_digit_position: " << x.first_digit_position() << "\n";	// 0

	std::cout << "x.first_digit_value: " << x.first_digit_value() << "\n";		// x[0]
*/


	return 0;
}